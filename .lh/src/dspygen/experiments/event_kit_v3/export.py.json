{
    "sourceFile": "src/dspygen/experiments/event_kit_v3/export.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1724731471255,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1724731546323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,18 +40,18 @@\n     \"\"\"Extract the specified fields from an event object\"\"\"\n     return [encodeField(getattr(event, nm)) for nm in fieldnames]\n \n \n-def calendarFields(calendar, fieldnames):\n-    \"\"\"Generate the records for all events in the calendar\"\"\"\n+def calendarFields(calendars, fieldnames):\n+    \"\"\"Generate the records for all events in the given calendars\"\"\"\n     store = EventKit.EKEventStore.alloc().init()\n \n     # Define a date range: start from today to one year in the future\n     start_date = datetime.now()\n     end_date = start_date + timedelta(days=365)\n \n     predicate = store.predicateForEventsWithStartDate_endDate_calendars_(\n-        start_date, end_date, [calendar]\n+        start_date, end_date, calendars\n     )\n     events = store.eventsMatchingPredicate_(predicate)\n \n     for event in events:\n@@ -61,24 +61,25 @@\n def main():\n     \"\"\"Main entry point\"\"\"\n     store = EventKit.EKEventStore.alloc().init()\n \n-    # Request access to the user's calendar\n+    # Request access to the user's calendars\n     def request_access_handler(granted, error):\n         if not granted:\n-            print(\"Access to calendar was not granted.\")\n+            print(\"Access to calendars was not granted.\")\n             return\n \n     store.requestAccessToEntityType_completion_(\n         EventKit.EKEntityTypeEvent, request_access_handler\n     )\n \n-    calendar = store.defaultCalendarForNewEvents()\n+    # Get all calendars\n+    calendars = store.calendarsForEntityType_(EventKit.EKEntityTypeEvent)\n \n-    with open('calendar_events.csv', \"w\", newline=\"\") as fp:\n+    with open('all_calendar_events.csv', \"w\", newline=\"\") as fp:\n         csvStream = csv.writer(fp)\n         csvStream.writerow([f[0] for f in FIELD_NAMES])\n-        for row in calendarFields(calendar, [f[1] for f in FIELD_NAMES]):\n+        for row in calendarFields(calendars, [f[1] for f in FIELD_NAMES]):\n             csvStream.writerow(row)\n \n \n if __name__ == \"__main__\":\n"
                },
                {
                    "date": 1724731678364,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,91 @@\n+#!/usr/bin/env python3\n+\"\"\"\n+This script provides an example of how to use the EventKit framework.\n+It creates a CSV file named 'events_export.csv' containing information about all events in all calendars.\n+\n+Usage:\n+    python exportAllEvents.py\n+\"\"\"\n+\n+import csv\n+from datetime import datetime, timedelta\n+\n+import EventKit\n+\n+# The names of fields in the export, and the corresponding property.\n+FIELD_NAMES = (\n+    (\"Calendar\", \"calendar.title\"),\n+    (\"Title\", \"title\"),\n+    (\"Start Date\", \"startDate\"),\n+    (\"End Date\", \"endDate\"),\n+    (\"Location\", \"location\"),\n+    (\"Notes\", \"notes\"),\n+)\n+\n+def encodeField(value):\n+    \"\"\"\n+    Encode a value into a string\n+    \"\"\"\n+    if value is None:\n+        return \"\"\n+\n+    if isinstance(value, datetime):\n+        return value.strftime(\"%Y-%m-%d %H:%M:%S\")\n+\n+    return str(value)\n+\n+\n+def eventToFields(event, fieldnames):\n+    \"\"\"Extract the specified fields from an event object\"\"\"\n+    field_values = []\n+    for field in fieldnames:\n+        parts = field.split('.')\n+        attr = event\n+        for part in parts:\n+            attr = getattr(attr, part)\n+        field_values.append(encodeField(attr))\n+    return field_values\n+\n+\n+def calendarFields(calendar, fieldnames, store):\n+    \"\"\"Generate the records for all events in the calendar\"\"\"\n+    # Define a date range: start from today to one year in the future\n+    start_date = datetime.now()\n+    end_date = start_date + timedelta(days=365)\n+    \n+    predicate = store.predicateForEventsWithStartDate_endDate_calendars_(\n+        start_date, end_date, [calendar]\n+    )\n+    events = store.eventsMatchingPredicate_(predicate)\n+\n+    for event in events:\n+        yield eventToFields(event, fieldnames)\n+\n+\n+def main():\n+    \"\"\"Main entry point\"\"\"\n+\n+    store = EventKit.EKEventStore.alloc().init()\n+\n+    # Request access to the user's calendar\n+    def request_access_handler(granted, error):\n+        if not granted:\n+            print(\"Access to calendar was not granted.\", file=sys.stderr)\n+            sys.exit(1)\n+\n+    store.requestAccessToEntityType_completion_(\n+        EventKit.EKEntityTypeEvent, request_access_handler\n+    )\n+\n+    calendars = store.calendarsForEntityType_(EventKit.EKEntityTypeEvent)\n+\n+    with open(\"events_export.csv\", \"w\", newline=\"\") as fp:\n+        csvStream = csv.writer(fp)\n+        csvStream.writerow([f[0] for f in FIELD_NAMES])\n+        for calendar in calendars:\n+            for row in calendarFields(calendar, [f[1] for f in FIELD_NAMES], store):\n+                csvStream.writerow(row)\n+\n+\n+if __name__ == \"__main__\":\n+    main()\n"
                }
            ],
            "date": 1724731471255,
            "name": "Commit-0",
            "content": "#!/usr/bin/env python3\n\"\"\"\nThis script provides a short example of how to use the EventKit framework.\nIt creates a CSV file named 'calendar_events.csv' containing information\nabout all events in the user's default calendar for the next year.\n\nUsage:\n    python exportEvents.py\n\"\"\"\n\nimport csv\nfrom datetime import datetime, timedelta\n\nimport EventKit\n\n# The names of fields in the export, and the corresponding property.\nFIELD_NAMES = (\n    (\"Title\", \"title\"),\n    (\"Start Date\", \"startDate\"),\n    (\"End Date\", \"endDate\"),\n    (\"Location\", \"location\"),\n    (\"Notes\", \"notes\"),\n)\n\n\ndef encodeField(value):\n    \"\"\"\n    Encode a value into a string\n    \"\"\"\n    if value is None:\n        return \"\"\n\n    if isinstance(value, datetime):\n        return value.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    return str(value)\n\n\ndef eventToFields(event, fieldnames):\n    \"\"\"Extract the specified fields from an event object\"\"\"\n    return [encodeField(getattr(event, nm)) for nm in fieldnames]\n\n\ndef calendarFields(calendar, fieldnames):\n    \"\"\"Generate the records for all events in the calendar\"\"\"\n    store = EventKit.EKEventStore.alloc().init()\n\n    # Define a date range: start from today to one year in the future\n    start_date = datetime.now()\n    end_date = start_date + timedelta(days=365)\n\n    predicate = store.predicateForEventsWithStartDate_endDate_calendars_(\n        start_date, end_date, [calendar]\n    )\n    events = store.eventsMatchingPredicate_(predicate)\n\n    for event in events:\n        yield eventToFields(event, fieldnames)\n\n\ndef main():\n    \"\"\"Main entry point\"\"\"\n    store = EventKit.EKEventStore.alloc().init()\n\n    # Request access to the user's calendar\n    def request_access_handler(granted, error):\n        if not granted:\n            print(\"Access to calendar was not granted.\")\n            return\n\n    store.requestAccessToEntityType_completion_(\n        EventKit.EKEntityTypeEvent, request_access_handler\n    )\n\n    calendar = store.defaultCalendarForNewEvents()\n\n    with open('calendar_events.csv', \"w\", newline=\"\") as fp:\n        csvStream = csv.writer(fp)\n        csvStream.writerow([f[0] for f in FIELD_NAMES])\n        for row in calendarFields(calendar, [f[1] for f in FIELD_NAMES]):\n            csvStream.writerow(row)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        }
    ]
}