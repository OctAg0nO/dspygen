{
    "sourceFile": "src/dspygen/rdddy/service_colony.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1724181260042,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1724181270459,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -130,6 +130,7 @@\n                 await self.channel.unsubscribe()\n             if self.realtime_client.is_connected:\n                 await self.realtime_client.close()\n             logger.debug(\"Inhabitant system shutdown complete.\")\n-        \n+        except RuntimeError as e:\n+            logger.error(f\"Error shutting down inhabitant system: {e}\")\n \n"
                },
                {
                    "date": 1724181281943,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -131,6 +131,7 @@\n             if self.realtime_client.is_connected:\n                 await self.realtime_client.close()\n             logger.debug(\"Inhabitant system shutdown complete.\")\n         except RuntimeError as e:\n-            logger.error(f\"Error shutting down inhabitant system: {e}\")\n+            # Event loop already closed\n+            pass\n \n"
                }
            ],
            "date": 1724181260042,
            "name": "Commit-0",
            "content": "import asyncio\nfrom typing import TYPE_CHECKING, Optional, TypeVar, cast\n\nimport inject\nimport reactivex as rx\nfrom loguru import logger\nfrom reactivex import operators as ops\nfrom reactivex.scheduler.eventloop import AsyncIOScheduler\n\nfrom realtime import RealtimeSubscribeStates\n\nfrom dspygen.rdddy.async_realtime_client import AsyncRealtimeClient\nfrom dspygen.rdddy.base_message import BaseMessage, MessageFactory\n\nif TYPE_CHECKING:\n    from dspygen.rdddy.base_inhabitant import BaseInhabitant\n\nT = TypeVar(\"T\", bound=\"BaseInhabitant\")\n\n\nclass ServiceColony:\n    \"\"\"Orchestrates inhabitant lifecycle management, message passing, and system-wide coordination within\n    the RDDDY framework.\"\"\"\n    def __init__(self, loop: Optional[asyncio.AbstractEventLoop] = None, realtime_client: AsyncRealtimeClient = None):\n        \"\"\"Initializes the ServiceColony with a real-time client connection.\"\"\"\n        self.realtime_client = inject.instance(AsyncRealtimeClient) if realtime_client is None else realtime_client\n        self.channel = None\n        self.inhabitants: dict[int, \"BaseInhabitant\"] = {}\n        self.loop = loop if loop is not None else asyncio.get_event_loop()\n        self.scheduler = AsyncIOScheduler(loop=self.loop)\n        self.event_stream = rx.subject.Subject()\n\n    async def connect(self):\n        \"\"\"Connect to the WebSocket and join the main channel.\"\"\"\n        await self.realtime_client.connect()\n\n        # Create and join the channel (e.g., \"service_colony:lobby\")\n        self.channel = self.realtime_client.channel(\"service_colony:lobby\")\n        await self.channel.subscribe(self._on_channel_subscribe)\n        logger.info(f\"Joined channel 'service_colony:lobby'\")\n\n        # Listen for incoming messages\n        self.channel.on_broadcast(\"message\", self._on_message_received)\n\n    def _on_channel_subscribe(self, status: RealtimeSubscribeStates, err: Optional[Exception]):\n        \"\"\"Handle subscription status.\"\"\"\n        if status == RealtimeSubscribeStates.SUBSCRIBED:\n            logger.info('Successfully subscribed to the channel.')\n        else:\n            logger.error(f'Error subscribing to channel: {err}')\n\n    def _on_message_received(self, payload: dict):\n        \"\"\"Callback for handling incoming messages.\"\"\"\n        message = MessageFactory.create_message(payload)\n        asyncio.run_coroutine_threadsafe(self.distribute_message(message), self.loop)\n\n    async def distribute_message(self, message):\n        \"\"\"Distributes a message within the inhabitant system.\"\"\"\n        self.event_stream.on_next(message)\n        for inhabitant in list(self.inhabitants.values()):\n            await self.send(inhabitant.inhabitant_id, message)\n\n    async def inhabitant_of(self, inhabitant_class, **kwargs) -> T:\n        \"\"\"Creates a new inhabitant instance and starts its mailbox processing loop.\"\"\"\n        inhabitant = inhabitant_class(self, **kwargs)\n        self.inhabitants[inhabitant.inhabitant_id] = inhabitant\n        await inhabitant.start(self.scheduler)\n        logger.info(f\"Inhabitant {inhabitant.inhabitant_id} started\")\n        return inhabitant\n\n    async def inhabitants_of(self, inhabitant_classes, **kwargs) -> list[T]:\n        \"\"\"Creates multiple inhabitant instances of different types and starts their mailbox processing loops.\"\"\"\n        return [await self.inhabitant_of(cls, **kwargs) for cls in inhabitant_classes]\n\n    async def publish(self, message: \"BaseMessage\"):\n        \"\"\"Publishes a message to the inhabitant system for distribution.\"\"\"\n        logger.debug(f\"Publishing message: {message}\")\n        if type(message) is BaseMessage:\n            raise ValueError(\"The base Message class should not be used directly. Please use a subclass of Message.\")\n\n        # Send message via the real-time channel\n        await self.channel.send_broadcast(\"message\", message.model_dump_json())\n        self.event_stream.on_next(message)\n\n        for inhabitant in list(self.inhabitants.values()):\n            await self.send(inhabitant.inhabitant_id, message)\n\n    async def remove_inhabitant(self, inhabitant_id):\n        \"\"\"Removes an inhabitant from the inhabitant system.\"\"\"\n        inhabitant = self.inhabitants.pop(inhabitant_id, None)\n        if inhabitant:\n            logger.debug(f\"Removing inhabitant {inhabitant_id}\")\n        else:\n            logger.debug(f\"Inhabitant {inhabitant_id} not found for removal\")\n        logger.debug(f\"Current inhabitants count: {len(self.inhabitants)}\")\n\n    async def send(self, inhabitant_id: int, message: \"BaseMessage\"):\n        \"\"\"Sends a message to a specific inhabitant within the inhabitant system.\"\"\"\n        inhabitant = self.inhabitants.get(inhabitant_id)\n        if inhabitant:\n            inhabitant.mailbox.on_next(message)\n            await asyncio.sleep(0)\n        else:\n            logger.debug(f\"Inhabitant {inhabitant_id} not found.\")\n\n    async def wait_for_message(self, message_type: type) -> \"BaseMessage\":\n        \"\"\"Waits for a message of a specific type to be published to the inhabitant system.\"\"\"\n        loop = asyncio.get_event_loop()\n        future = loop.create_future()\n\n        def on_next(msg):\n            if isinstance(msg, message_type):\n                future.set_result(msg)\n                subscription.dispose()\n\n        subscription = self.event_stream.pipe(\n            ops.filter(lambda msg: isinstance(msg, message_type))\n        ).subscribe(on_next)\n\n        return await future\n\n    def __getitem__(self, inhabitant_id) -> T:\n        \"\"\"Retrieves an inhabitant by its ID from the inhabitant system.\"\"\"\n        return cast(T, self.inhabitants.get(inhabitant_id))\n\n    async def shutdown(self):\n        \"\"\"Shuts down the inhabitant system and terminates all inhabitants.\"\"\"\n        try:\n            if self.channel:\n                await self.channel.unsubscribe()\n            if self.realtime_client.is_connected:\n                await self.realtime_client.close()\n            logger.debug(\"Inhabitant system shutdown complete.\")\n        \n\n"
        }
    ]
}